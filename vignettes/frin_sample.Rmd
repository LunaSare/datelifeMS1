---
title: "Fringillidae sample"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{frin_sample}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(datelifeMS1)
library(datelife)
data("opentree_chronograms", package = "datelife")
# if(!require("datelife")) {
#   devtools::install_github("https://github.com/phylotastic/datelife/tree/database_update")
# }
data("frin_sample_dres", package = "datelifeMS1")
devtools::load_all()
```

## Get a subsample of Fringiliidae

```{r}
frin_sample <- c("Fringilla montifringilla",
             "Loxioides bailleui",
             "Vestiaria coccinea",
             "Carpodacus roseus",
             "Pyrrhula aurantiaca",
             "Pyrrhula nipalensis",
             "Serinus syriacus",
             "Serinus serinus",
             "Loxia scotica",
             "Emberiza leucocephalus",
             "Emberiza citrinella",
             "Schoeniclus elegans",
             "Rhodothraupis celaeno",
             "Peucedramus taeniatus",
             "Platispiza crassirostris",
             "Pheucticus tibialis")
# frin_sample <- sample(x = dquery$cleaned_names, size = 15)
```

## Get a `datelifeQuery` object

```{r}

frin_sample_dquery <- datelife::make_datelife_query(input = frin_sample,
                                                    use_tnrs = TRUE)

# usethis::use_data(frin_sample_dquery, overwrite = TRUE)
```

## Get a `datelifeResult` object

```{r}
frin_sample_dres = datelife::get_datelife_result(input = frin_sample_dquery, cache = opentree_chronograms)

# usethis::use_data(frin_sample_dres, overwrite = TRUE)
```


```{r}
frin_sample_dsumm <- datelife:::summary.datelifeResult(datelife_query = frin_sample_dquery, object = frin_sample_dres)

# usethis::use_data(frin_sample_dsumm, overwrite = TRUE)
```


## Get all node ages

```{r}
frin_sample_all_calibrations <- datelife::extract_calibrations_phylo(input = frin_sample_dsumm$phylo_all, each = FALSE)

# usethis::use_data(frin_sample_all_calibrations, overwrite = TRUE)
```


## Match to sdm tree and plot

```{r}
frin_sample_matched_sdm <- datelife::match_all_calibrations(phy = frin_sample_dsumm$phylo_sdm, calibrations = frin_sample_all_calibrations)

# usethis::use_data(frin_sample_matched_sdm, overwrite = TRUE)


frin_sample_csumm_sdm <- datelife:::summary.matchedCalibrations(frin_sample_matched_sdm$matched_calibrations)

# usethis::use_data(frin_sample_csumm_sdm, overwrite = TRUE)



svg(filename = "../figures/frin_sample_sdm_ages.svg",
    height = 5,
    width = 7)
datelifeplot:::plot_node_ages(frin_sample_dsumm$phylo_sdm,
               cex_tips = 0.7,
               calibration_summary = frin_sample_csumm_sdm)
dev.off()

```

## Match to median tree and plot

Plot the tree with node labels:

```{r}
svg(filename = "../figures/frin_sample_median_node_names.svg",
    height = 5,
    width = 7)
ape::plot.phylo(frin_sample_dsumm$phylo_median, cex = 0.7)
ape::axisPhylo()
ape::nodelabels()
dev.off()
```
The calibration distribution object is generated by matching the input data to the phylo median tree, we need to fix this.

```{r}
ages_20 <- frin_sample_dsumm$phylo_median$calibration_distribution$`20`
median(ages_20)
```

```{r}
frin_sample_matched_median <- datelife::match_all_calibrations(phy = frin_sample_dsumm$phylo_median, calibrations = frin_sample_all_calibrations)

# usethis::use_data(frin_sample_matched_median, overwrite = TRUE)


frin_sample_csumm_median <- datelife:::summary.matchedCalibrations(frin_sample_matched_median$matched_calibrations)

# usethis::use_data(frin_sample_csumm_median, overwrite = TRUE)

svg(filename = "../figures/frin_sample_median_ages.svg",
    height = 5,
    width = 7)
datelifeplot:::plot_node_ages(frin_sample_dsumm$phylo_median,
               cex_tips = 0.7,
               calibration_summary = frin_sample_csumm_median)
dev.off()

```


```{r}

median_matrix <- datelife::datelife_result_median_matrix(frin_sample_dres)
names(frin_sample_dres)
str(median_matrix)
tt <- as.data.frame(as.table(median_matrix))
colnames(tt) <- c("taxonA", "taxonB", "age")
class(tt$age)
xx <- datelife::extract_calibrations_dateliferesult(input = frin_sample_dres)

for (i in seq(frin_sample_dres)) {
  if ("Carpodacus roseus" %in% rownames(frin_sample_dres[[i]])) {
    print("Carpodacus roseus")
    rowsies <- which("Carpodacus roseus" == rownames(frin_sample_dres[[i]]))
    colsies <- NA
    if ("Loxioides bailleui" %in% colnames(frin_sample_dres[[i]])) {
      print("Loxioides bailleui")
      colsies <- which("Loxioides bailleui" == colnames(frin_sample_dres[[i]]))
    } else if ("Vestiaria coccinea" %in% colnames(frin_sample_dres[[i]])) {
      print("Vestiaria coccinea")
      colsies <- which("Vestiaria coccinea" == colnames(frin_sample_dres[[i]]))
    }
    if (!is.na(colsies)) {
    print(names(frin_sample_dres)[i])
    print(frin_sample_dres[[i]][rowsies, colsies])
  }
  }
}
x <- c(33.16057, 33, 26.89789, 28.57216)
median(x)/2

datelife_result <- frin_sample_dres
taxonA <- "Carpodacus roseus"
taxonB <- c("Loxioides bailleui", "Vestiaria coccinea")
explore_node <- function(taxonA, taxonB, datelife_result, single = TRUE){
  node_ages <- c()
  for (i in seq(datelife_result)) {
    rowsies <- rownames(datelife_result[[i]]) %in% taxonA
    columnsies <- colnames(datelife_result[[i]]) %in% taxonB
    node_ages_i <- datelife_result[[i]][rowsies, columnsies]
    if (length(node_ages_i) == 0) {
      next
    }
    names(node_ages_i) <- rep(names(datelife_result)[i], length(node_ages_i))
    message("Node present in chronogram", i)
      if (single) { # return only one data point per chronogram
      # if there are many taxa on one clade, data points appear duplicated
      # but these are not used for median estimates
      node_ages_i <- node_ages_i[1]
    }
    node_ages <- c(node_ages, node_ages_i)
  }
  node_ages
}

explore_node(taxonA = "Carpodacus roseus", taxonB = c("Loxioides bailleui", "Vestiaria coccinea"), datelife_result = frin_sample_dres)

frin_sample_dsumm$phylo_median$tip.label
node_test <- explore_node(taxonA = "Platyspiza crassirostris",
             taxonB = c("Pheucticus tibialis", "Rhodothraupis celaeno"),
             datelife_result = frin_sample_dres)

median(node_test/2)
```

Let's verify that the pair actually is in the input tree:
```{r}
frin_sample_dres$`Hedges, S. Blair, Julie Marin, Michael Suleski, Madeline Paymer, Sudhir Kumar. 2015. Tree of life reveals clock-like speciation and diversification. Molecular Biology and Evolution 32 (4): 835-845`[, "Loxioides bailleui"]
```
Calibration for "Carpodacus_roseus" vs "Loxioides bailleui" exists in Hedges tree
but it is absent from the extract_calibrations object.

Let's try to extract calibrations from the Hedges subset tree only:

```{r}
hedges_subset_tree <- frin_sample_dsumm$phylo_all$`Hedges, S. Blair, Julie Marin, Michael Suleski, Madeline Paymer, Sudhir Kumar. 2015. Tree of life reveals clock-like speciation and diversification. Molecular Biology and Evolution 32 (4): 835-845`

hedges_subset_tree$tip.label
plot(hedges_subset_tree)

# code to run congruification on the Hedges subset tree:
# extract_calibrations_phylo(input = frin_sample_dsumm$phylo_all$`Hedges, S. Blair, Julie Marin, Michael Suleski, Madeline Paymer, Sudhir Kumar. 2015. Tree of life reveals clock-like speciation and diversification. Molecular Biology and Evolution 32 (4): 835-845`)

```
We did not need to extract calibrations from Hedges subset tree. 
Plotting the tree gives us a very good idea of what is going on:
The "Carpodacus_roseus"/"Loxioides bailleui" node is conflicting between the Hedges subset input tree and the median tree.

Even though the median tree uses the node ages for "Carpodacus_roseus"/"Loxioides bailleui" pair from Hedges, when the median matrix is clustered, it creates new relationship that conflicts with the "Carpodacus_roseus"/"Loxioides bailleui" clade in Hedges.
So, when trying to match calibrations from Hedges into the median tree, the node age for "Carpodacus_roseus"/"Loxioides bailleui" pair is dropped (excluded from potentially usable calibrations), because it points to a clade that conflicts with the topology of the median tree.

This shows that we cannot use the output of extract_all_calibrations/matched_all_calibrations to check that the input data is coherent with the median tree results.

Next step: plot the actual input data on top of the median tree, and SDM tree.

```{r}
node_ages <- datelife::matrices_to_table(frin_sample_dres)
head(node_ages, 20)
nrow(node_ages)
```


```{r}
frin_sample_dres_matched_median <- datelife::match_all_calibrations(phy = frin_sample_dsumm$phylo_median, calibrations = node_ages)
# usethis::use_data(frin_sample_dres_matched_median, overwrite = TRUE)
  
head(frin_sample_dres_matched_median$matched_calibrations, 20)
# usethis::use_data(frin_sample_dres_matched_median, overwrite = TRUE)

frin_sample_dres_csumm_median <- datelife:::summary.matchedCalibrations(frin_sample_dres_matched_median$matched_calibrations)

# usethis::use_data(frin_sample_dres_csumm_median, overwrite = TRUE)

colnames(frin_sample_dres_csumm_median$in_phy)
svg(filename = "../figures/frin_sample_median_input_ages.svg",
    height = 5,
    width = 7)
datelifeplot:::plot_node_ages(frin_sample_dsumm$phylo_median,
               cex_tips = 0.7,
               calibration_summary = frin_sample_dres_csumm_median,
               lwd_bars = 7,
               color_bars = "#80808050")
dev.off()

```


Informative comparison: We could compare actual input data points vs matched calibrations to see how much different the resulting summary topology is from the input trees!
For example, if node ages from the input trees are close to the node ages of the summary tree, then there is not a lot of conflict across the input trees.
In contrast, if most node ages from the input tree are far away from the node ages of the summary tree, there might be a lot of phylogenetic conflict across the input trees.

Congruification works similar to how OpenTree conflict resolution works (i.e., the phylogenetic problem algorithm). Basically it takes the most inclusive clade and ignores data from clades that conflict with this most inclusive clades.



## Match to phylo biggest and plot











